# Sets
These are all different ways of writing the same set starting with the most simple grammar

## Grammar
$$ \text{t = true | false | (if t t t) | 0 | succ t | pred t | isZero t}$$
These are the possible value of t 

Inductive defn:
$$\text{\{true, false, 0\}} \subseteq T$$
true, false and 0 are all in T
$$\forall t : T \text{\{succ t, pred t, isZero t\}} \subseteq T$$
succ t, pred t, and isZero t are all in T if t is in T
$$\forall t_{0}, t_{1}, t_{2} : T \{\text{if} \space t_{0} t_{1} t_{2}\} \in T$$
(if t0, t1, t2) is in T if t0, t1, t2 are all in T


## Inference rules
Recall: Numerator is the if part (antecedent), if numerator is true then the denom (consequence) is true
	If there is no numerator, then the consequence must be true and it is axiom (something we just have to accept)


$$\frac{}{\text{true} \in T \text{ false} \in T \text{ 0} \in T}$$
Here, true/false/0 being in T is an axiom, something we just have to accept

$$\frac{t \in T}{\text{succ t} \in T} \frac{t \in T}{\text{pred t} \in T} \frac{t \in T}{\text{isZero t} \in T}$$
if t is in T, then succ/pred/isZero is in T

This is inductive because since succ t is in the set, then succ succ succ ...  succ t is in the set

Notice how this depends on this terminating so you have to prove that the search does/doesn't terminate instead of just running it (halting problem, can't do)


If the set is finite then yay we are good but that means it's weak

## Fixed point

$S_{0} = \emptyset$ 
S0 is the empty set we start with nothing
$S_{n+1} = \text{\{true, false, 0\}} \cup \text{\{succ t ... \}}$ 
Sn+1 is every term we can construct from Sn 
$T = \cup S_{i}$
T is the union of all Si where i ranges over the natural numbers



# Equational reasoning 

**Defining terms:**
Define consts: a function that finds the set of unique constants in a term from T
$\text{consts true} = \{true\}$
$\text{consts false} = \{false\}$
$\text{consts 0} = \{0\}$
$\text{consts succ t} = \text{ consts t }$
...
$\text{consts (if } t_{0} t_{1} t_{2}) = \text{consts } t_{0} \cup \text{consts } t_{1} \cup \text{consts } t_{2}$   

This is like trying to find all the values (terms that cant be reduced further)
Also, you can substitute true with the set containing true


**Evaluating terms:**
If A = B then you can replace A with B wherever A occurs (Leibniz Equality)

consts (if true (succ 0) (pred 0))  = ... = {true, 0}

*Note that this is a proof and program execution*

This is also complete because we have a rule for every term


# Induction
**Math induction**: If P(0) holds and $\forall n \dot P(n) \Rightarrow P(n+1)$ then P holds for every n

For an example, prove that number of constants is always less than or equal than the number of terms
Prove: $\forall t, \text{|consts t|} \leq \text{terms t}$
- Case `true`, |consts true| $\leq$ terms true
	- |{true}| $\leq 1$
	- 1 $\leq$ 1
- Case `false`, |consts false| $\leq$ terms false
	- |{false}| $\leq 1$
	- $1 \leq 1$
- Case `succ`: $\forall t$, | const t| $\leq$ terms t $\Rightarrow$ | consts succ t | $\leq$ terms succ t


- Depth induction 
	- For each term t, given p(r) holds for all r where depth(r) < depth(t), then p(t) holds for t
- Size induction
	- For each term t, given p(r) for all r such that size(r) < size(t) we can show P(t) holds for all t
- Structural induction:
	- If for each term t, given P(r) for all immediate subterms r of t, we can show P(t)
	- If true for the parts, its true for the whole



## Small step operational semantics
the definitions of consts and terms (how these terms are defined) are the semantics of the function
single step is when one term evals to another in 1 step 
$$t\rightarrow t'$$
Homogenous relation (we go from same domain to range or terms in my language evaluate to terms in my language)
	Good because we can string together steps


$\frac{}{true \rightarrow true} \frac{}{false \rightarrow false} \frac{}{0 \rightarrow 0}$ 
Note that this means nothing is actually happening 
$\frac{}{succ\space 0 \rightarrow succ \space 0}$  We don't have 1 so we are just keeping successor
$\frac{}{pred \space 0 \rightarrow pred \space 0}$ THIS IS BAD

Here is the thing, these don't actually evaluate so why add a rule. WHen we get to true we are chilling so they don't evaluate 


what we want to show is that pre